\section{Etat au commencement du projet}
Le projet etant open-source et actif, il evolue sans cesse. La partie sur laquelle nous avons travaille est relativement stable mais son utilisation peut varier dans le code. Nous allons voir la portee de l'utilisation de nanoXml, comment il est utilise et enfin la solution apportee.

% -> Utilisation intensive de XML
% -> Philosophie de nanoXml et de DOM differente
% -> -> DOM : Tout est noeud
% -> -> NanoXml : Base sur les tags (elements)
\section{Nanoxml}
Comme nous avons pu le voir, IzPack utilise intessement des fichiers XML pour gerer la generation d'installations. En effet, les fichiers XML presentent l'avantage d'etre lisible, ecrivable a la main et traitables. Pour traiter ces fichiers, une librairie a ete utilisee, il s'agit de NanoXml.
\subsection{Le projet NanoXml}
NanoXml est une librairie open-source de gestion de Xml java. Elle presente la particularite d'etre legere (~108Ko). Il est possible, grace a cette librairie, d'ecrire ou de parser des fichiers Xml. Une fois le fichier parse, on recupere en memoire la structure de l'arbre Xml qui peut alors etre exploite. Le choix de cette librairie a ete faite au commencement de Izpack a cause de sa taille. En effet, il ete important de ne pas surcharge l'application a installe par un installeur imposant. 

Cependant, ce projet n'est plus de mise a jour depuis 7 ans. Entretemps, java integre depuis la version 1.4 un parser Xml et des bugs ont ete decouvert. Il devenait interessant de remplacer NanoXml par Javax, la librairie fournie par la machine virtuelle.
\subsection{Les differentes composantes de NanoXml}
On trouve differents elements dans NanoXml.
\subsubsection{StdXMLParser}
Le parser permet de creer un arbre logique representant le fichier xml qui lui a ete passe. Il est systematiquement utilise au moment de la lecture du fichier afin de recuperer l'arbre.
\subsubsection{XMLElement}
Le XMLElement represente un element logique du xml en memoire. Par exemple :
\begin{verbatim}
<root>
	<enfant>
		content
	</enfant>
</root>
\end{verbatim}
En parsant un fichier contenant ce Xml, on a un XMLElement nomme root qui possede 1 enfant. Son enfant est un XMLElement ne dont le contenue est content.

L'arborescence du XML est donc realise par un ensemble de XMLElement. XMLElement permet de recuperer la liste des enfants, le contenu, recherche un enfant par son nom, retirer un enfant, ajouter un enfant ou modifier le contenu. Il s'agit de loin de la classe la plus utilisee de la librairie NanoXml dans Izpack. En effet, on compte pas moins de 499 utilisations au commencement de ce projet.
\subsubsection{XMLWriter}
Le XMLWriter permet d'ecrire des fichiers XML. Il reproduit, a partir d'un XML element, le fichier XML correspondant. Il n'est utilise que pour generer un xml temporaire ou pour ecrire le xml d'installation automatique. 
\subsection{Utilisation typique dans Izpack}
\subsubsection{Parse de fichier}
Le parse du fichier est execute pour recuperer le XML.
\begin{verbatim}
        StdXMLParser parser = new StdXMLParser();
        parser.setBuilder(XMLBuilderFactory.createXMLBuilder());
        parser.setReader(new StdXMLReader(in));
        parser.setValidator(new NonValidator());

        // We get the data
        XMLElement data = (XMLElement) parser.parse();
\end{verbatim}
\subsubsection{Ecriture d'un xml}
\begin{verbatim}
       XMLWriter writer = new XMLWriter(out);
        ...
        writer.write(xmlElemetn);
\end{verbatim}
\subsubsection{Utilisation de XMLElement}
\begin{verbatim}
String id = el.getAttribute("id");
String packImgId = el.getAttribute("packImgId");
boolean loose = "true".equalsIgnoreCase(el.getAttribute("loose", "false"));
String description = requireChildNamed(el, "description").getContent();
boolean required = requireYesNoAttribute(el, "required");
String group = el.getAttribute("group");
String installGroups = el.getAttribute("installGroups");
String excludeGroup = el.getAttribute("excludeGroup");
boolean uninstall = "yes".equalsIgnoreCase(el.getAttribute("uninstall", "yes"));
String parent = el.getAttribute("parent");
String conditionid = el.getAttribute("condition");
\end{verbatim}
\section{Elaboration de la solution}
Face a ce probleme, notre travail a ete de chercher une solution pour permettre de remplacer de NanoXml et de l'appliquer au projet. Mais ils y avaient plusieurs problemes a cela.
\subsection{Les differences entre javax et NanoXml}

\begin{verbatim}
<!--comment>commentaire<comment-->
<root>
	<noeud1>text</noeud1>
</root>

Nano -> root possede 1 enfant
DOM -> root possede 3 enfants (\n; <noeud1>; \n)
\end{verbatim}
\subsection{Remplacer les appels}
\subsection{Utilisation d'un design pattern}
Extraction d'interface du xmlElement.
-> IXmlElements
-> IXmlParser
-> IXmlWriter

XMLElements de NanoXml ~ Node Element

Dom possede pls types de noeuds : Comment, Text, element

Xinclude : gerer de maniere native par Javax
Xfragment Non present dans la specifiaction W3C:
-> Permet include de noeuds sans racines
Passage par une feuille XSL
-> include puis suppression des Xfragment
\section{Application et tests}
\subsection{Test unitaires de comparaison}
Comparaison entre le comportement de nanoXml et de l'adaptateur
\subsection{Integration a IzPack}
\subsection{Test Globale et Profiling}

\section{Resultats}
\subsection{Diminution de la taille des installeurs}
NanoXml : 116Ko
Adaptateur : 44Ko
\subsection{Support de fonctionnalitees XML}
DTD, xinclude
