\section{Etat au commencement du projet}
Le projet etant open-source et actif, il evolue sans cesse. La partie sur laquelle nous avons travaille est relativement stable mais son utilisation peut varier dans le code. Nous allons voir la portee de l'utilisation de nanoXml, comment il est utilise et enfin la solution apportee.

% -> Utilisation intensive de XML
% -> Philosophie de nanoXml et de DOM differente
% -> -> DOM : Tout est noeud
% -> -> NanoXml : Base sur les tags (elements)
\section{Nanoxml}
Comme nous avons pu le voir, IzPack utilise intessement des fichiers XML pour gerer la generation d'installations. En effet, les fichiers XML presentent l'avantage d'etre lisible, ecrivable a la main et traitables. Pour traiter ces fichiers, une librairies a ete utilisee, il s'agit de NanoXml.

\subsection{Le projet NanoXml}
NanoXml est une librairie open-source de gestion de Xml java. Elle presente la particularite d'etre legere (~108Ko). Il est possible, grace a cette librairie, d'ecrire ou de parser des fichiers Xml. Une fois le fichier parse, on recupere en memoire la structure de l'arbre Xml qui peut alors etre exploite. Le choix de cette librairie a ete faite au commencement de Izpack a cause de sa taille. En effet, il ete important de ne pas surcharge l'application a installe par un installeur imposant. 

Cependant, ce projet n'est plus de mise a jour depuis 7 ans. Entretemps, java integre depuis la version 1.4 un parser Xml et des bugs ont ete decouvert. Il devenait interessant de remplacer NanoXml par Javax, la librairie fournie par la machine virtuelle.
\subsection{Les differentes composantes de NanoXml}
On trouve differents elements dans NanoXml.
\subsubsection{StdXMLParser}
Le parser permet de creer un arbre logique representant le fichier xml qui lui a ete passe. Il est systematiquement utilise au moment de la lecture du fichier afin de recuperer l'arbre.
\subsubsection{XMLElement}

\subsubsection{XMLWriter}
Le XMLWriter permet d'ecrire des fichiers XML. Il reproduit, a partir d'un XML element, le fichier XML correspondant.




\begin{verbatim}
        StdXMLParser parser = new StdXMLParser();
        parser.setBuilder(XMLBuilderFactory.createXMLBuilder());
        parser.setReader(new StdXMLReader(in));
        parser.setValidator(new NonValidator());

        // We get the data
        XMLElement data = (XMLElement) parser.parse();
\end{verbatim}

\section{Elaboration de la solution}
\subsection{Les differences entre javax et NanoXml}
\begin{verbatim}
<!--comment>commentaire<comment-->
<root>
	<noeud1>text</noeud1>
</root>

Nano -> root possede 1 enfant
DOM -> root possede 3 enfants (\n; <noeud1>; \n)
\end{verbatim}
\subsection{Remplacer les appels}
\subsection{Utilisation d'un design pattern}
Extraction d'interface du xmlElement.
-> IXmlElements
-> IXmlParser
-> IXmlWriter

XMLElements de NanoXml ~ Node Element

Dom possede pls types de noeuds : Comment, Text, element

Xinclude : gerer de maniere native par Javax
Xfragment Non present dans la specifiaction W3C:
-> Permet include de noeuds sans racines
Passage par une feuille XSL
-> include puis suppression des Xfragment
\section{Application et tests}
\subsection{Test unitaires de comparaison}
Comparaison entre le comportement de nanoXml et de l'adaptateur
\subsection{Integration a IzPack}
\subsection{Test Globale et Profiling}

\section{Resultats}
\subsection{Diminution de la taille des installeurs}
NanoXml : 116Ko
Adaptateur : 44Ko
\subsection{Support de fonctionnalitees XML}
DTD, xinclude
